
__author__ = 'Сотников Владимир А.'
print("Данный файл содержит решения ДЗ №2 для блока Hard, автор", __author__)


# Задание-3: "Перевёрнутая башня" (Задача олимпиадного уровня)
#
# Вавилонцы решили построить удивительную башню —
# расширяющуюся к верху и содержащую бесконечное число этажей и комнат.
# Она устроена следующим образом — на первом этаже одна комната,
# затем идет два этажа, на каждом из которых по две комнаты, 
# затем идёт три этажа, на каждом из которых по три комнаты и так далее:
#         ...
#     12  13  14
#     9   10  11
#     6   7   8
#       4   5
#       2   3
#         1
#
# Эту башню решили оборудовать лифтом --- и вот задача:
# нужно научиться по номеру комнаты определять,
# на каком этаже она находится и какая она по счету слева на этом этаже.
#
# Входные данные: В первой строчке задан номер комнаты N, 1 ≤ N ≤ 2 000 000 000.
#
# Выходные данные:  Два целых числа — номер этажа и порядковый номер слева на этаже.
#
# Пример:
# Вход: 13
# Выход: 6 2
#
# Вход: 11
# Выход: 5 3


"""
	Почерканый листочек показывает, что:
	1. в каждом n-секторе живут n*n цифр, причем это n*n по сути отражает, что в секторе 1..n этажей на каждом из которых 1..n комнат
	2. Начиная от Groundfloor циферки живут в секторах, причем кол-во этих цифр в соотв. с п.1 :  1 + 2*2 + 3*3 + 4*4 + 5*5 ...
	3. Из теории рядов известно (ура, пригодилось), что такой ряд является степенным, знакоположительным и его можно свернуть до n(n+1)(2n+1)/6 . 
	4. Из пред пункта задаем n и получаем последнюю живущую цифру в этом секторе. Соотв., считая тоже самое для (n-1) сектора и +1 , то получаем с какого номера живут цифры в этом секторе 
	5. Далее, используя п. 1, получаем для заданного числа номер этажа в этом секторе
	6. Но нам-то надо номер этажа с Groundfloor. Для этого заметим, что это так же ряд, только 1 + 2 + 3 + 4 ... (даже простая арифметич. прогрессия) , для которого сумма первых n членов n(1+n)/2
	7. п. 6 необходимо считать для сектора (n-1) и далее прибавить найденное в. п.5

	Применение рядов должны смягчить время на поиск комнаты для очень больших n. (применение головного мозга вместо спинного :) 
	Дальнейшую экономию для больших N можно извлечь упрощая и один оставшийся While. Для этого можно взять интервал, на концах которого к-л маленький и большой сектор. 
	Понять, что наше число внутри этого интервала. На следующей итерации поделить интервал пополам, посмотреть где осталось число... И так сегментируя на каждой итерации уйти от перебора...  
"""


user_num=int(input("Введите положительное целое число "))

num_sect=1
prev_sect=0
Up_bound=0
Dw_bound=0

while Up_bound<user_num:
	Up_bound=Up_bound+num_sect*num_sect
	num_sect+=1

num_sect=num_sect-1
prev_sect=num_sect-1

Dw_bound=prev_sect*(prev_sect+1)*(2*prev_sect+1)/6+1



print("Ваше число " + str(user_num) + " живет в секторе " + str(num_sect) + " с нижней границей " + str(Dw_bound) + " и верхней " + str(Up_bound) )

# Нормируем на мин и макс в секторе и возьмем целое число этажей
Lev_on_sector=(Up_bound-Dw_bound-(Up_bound-user_num))//num_sect

# Нормируем на мин в секторе, а остаток от деления - комната слева
Room_on_lev=(user_num-Dw_bound+1)%num_sect


# если остаток от деления 0, значит последняя комната на этаже
if Room_on_lev==0:
	Room_on_lev=num_sect

Lev_all=prev_sect*(1+prev_sect)/2
lev_user_num=Lev_all+Lev_on_sector+1


print("Этаж " + str(lev_user_num) + " комната "+ str(Room_on_lev))